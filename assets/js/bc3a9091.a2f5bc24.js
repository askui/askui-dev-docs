"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[70796],{64988:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>y,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var r=n(17624),a=n(4552);const i={sidebar_position:3},s="Retry Strategy",o={id:"general/Executing Automations/retry-strategy",title:"Retry Strategy",description:"If an application you want to automate has random or dynamic waiting times a quick fix is to use waitFor(). This solution can lead to flaky tests and makes the workflows hard to comprehend.",source:"@site/docs/general/04-Executing Automations/retry-strategy.md",sourceDirName:"general/04-Executing Automations",slug:"/general/Executing Automations/retry-strategy",permalink:"/docs/next/general/Executing Automations/retry-strategy",draft:!1,unlisted:!1,editUrl:"https://pr.new/askui/askui-dev-docs",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Condition-Based Execution",permalink:"/docs/next/general/Element Selection/condition-based-execution"},next:{title:"Annotations, Screenshots and Videos",permalink:"/docs/next/general/Element Selection/annotations-and-screenshots"}},l={},c=[{value:"Exponential Retry Strategy",id:"exponential-retry-strategy",level:3},{value:"Fixed Retry Strategy",id:"fixed-retry-strategy",level:3},{value:"Linear Retry Strategy",id:"linear-retry-strategy",level:3},{value:"Implement Your Own Strategy",id:"implement-your-own-strategy",level:3}];function d(e){const t={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,a.M)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"retry-strategy",children:"Retry Strategy"})}),"\n",(0,r.jsxs)(t.p,{children:["If an application you want to automate has random or dynamic waiting times a quick fix is to use ",(0,r.jsx)(t.code,{children:"waitFor(<a few seconds>)"}),". This solution can lead to flaky tests and makes the workflows hard to comprehend."]}),"\n",(0,r.jsxs)(t.p,{children:["You can specify a dynamic ",(0,r.jsx)(t.code,{children:"RetryStrategy"})," instead or implement your own to get rid of ",(0,r.jsx)(t.code,{children:"waitFor()"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"exponential-retry-strategy",children:"Exponential Retry Strategy"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"ExponentialRetryStrategy"}),"  uses an exponential backoff algorithm."]}),"\n",(0,r.jsx)(t.p,{children:"Usage:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"aui = await UiControlClient.build({\n  ...\n  // Each retry delay: baseDelayMs * (2 ** attempt count)\n  // attempt count is 0-based\n  retryStrategy: new ExponentialRetryStrategy(5000, 3);\n});\n"})}),"\n",(0,r.jsx)(t.h3,{id:"fixed-retry-strategy",children:"Fixed Retry Strategy"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"FixedRetryStrategy"})," uses a constant delay for each retry attempt."]}),"\n",(0,r.jsx)(t.p,{children:"Usage:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"aui = await UiControlClient.build({\n  ...\n  retryStrategy: new FixedRetryStrategy(1000, 3);\n});\n"})}),"\n",(0,r.jsx)(t.h3,{id:"linear-retry-strategy",children:"Linear Retry Strategy"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"LinearRetryStrategy"})," implements a retry strategy that uses a linear backoff algorithm."]}),"\n",(0,r.jsx)(t.p,{children:"Usage:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"aui = await UiControlClient.build({\n  ...\n  // Each retry delay: baseDelayMs * attempt count\n  // attempt count is 1-based\n  retryStrategy: new LinearRetryStrategy(1000, 3);\n});\n"})}),"\n",(0,r.jsx)(t.h3,{id:"implement-your-own-strategy",children:"Implement Your Own Strategy"}),"\n",(0,r.jsxs)(t.p,{children:["You can also implement your own ",(0,r.jsx)(t.code,{children:"RetryStrategy"})," by implementing the following interface:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:"/**\n * Interface representing a retry strategy for operations.\n */\nexport interface RetryStrategy {\n  /**\n   * The base delay in milliseconds before the first retry.\n   */\n  baseDelayMs: number;\n\n  /**\n   * The maximum number of retry attempts.\n   */\n  retryCount: number;\n\n  /**\n   * Function to calculate the delay before the next retry attempt.\n   * @param attempt - The current retry attempt number (0-based).\n   * @returns The delay in milliseconds for the next retry.\n   */\n  getDelay(attempt: number): number;\n}\n"})})]})}function y(e={}){const{wrapper:t}={...(0,a.M)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},4552:(e,t,n)=>{n.d(t,{I:()=>o,M:()=>s});var r=n(11504);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);